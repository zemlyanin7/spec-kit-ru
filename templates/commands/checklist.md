---
description: Сформировать пользовательский чек-лист для текущей фичи на основе требований пользователя.
scripts:
  sh: scripts/bash/check-prerequisites.sh --json
  ps: scripts/powershell/check-prerequisites.ps1 -Json
---

## Чек-лист: «Unit Tests for English»

**ВАЖНОЕ ПОНЯТИЕ**: чек-листы — это **юнит-тесты для требований**. Они проверяют качество, ясность и полноту требований в выбранной области.

**НЕ предназначены для проверки реализации**:
- ❌ «Проверить, что кнопка кликется»
- ❌ «Протестировать обработку ошибок»
- ❌ «Убедиться, что API отдаёт 200»
- ❌ Сопоставление кода со спецификацией

**Предназначены для проверки качества требований**:
- ✅ «Описаны ли визуальные требования для всех типов карточек?» (полнота)
- ✅ «Квантифицировано ли понятие “prominent display”?» (чёткость)
- ✅ «Последовательны ли требования к hover-состояниям?» (согласованность)
- ✅ «Описаны ли требования доступности для клавиатурной навигации?» (охват)
- ✅ «Указано ли поведение при недоступности изображения логотипа?» (edge case)

**Метафора**: если спецификация — это «код» на английском, то чек-лист — его тесты. Вы проверяете, насколько требования готовы к реализации, а не то, работает ли реализация.

## Ввод пользователя

```text
$ARGUMENTS
```

Вы **ОБЯЗАНЫ** учитывать ввод пользователя, если он не пустой.

## Шаги выполнения

1. **Подготовка**: Запустите `{SCRIPT}` из корня и получите JSON с `FEATURE_DIR`, `AVAILABLE_DOCS`.
   - Пути должны быть абсолютными.
   - Экранируйте апострофы `'I'\''m Groot'` или используйте двойные кавычки.

2. **Уточните намерение** (динамически): сформулируйте до ТРЁХ уточняющих вопросов. Они должны:
   - Проистекать из слов пользователя + сигналов из spec/plan/tasks;
   - Затрагивать только существенную информацию для наполнения чек-листа;
   - Пропускаться, если ответ уже однозначно содержится в `$ARGUMENTS`;
   - Быть точнее, чем шире.

   Алгоритм:
   1. Извлечь сигналы: домен (auth, latency, UX), риски («critical», «compliance»), роль («QA», «security»), deliverables («a11y», «rollback»).
   2. Сгруппировать в до 4 фокусных областей, упорядочить по релевантности.
   3. Определить аудиторию/этап (автор, ревьюер, QA, релиз).
   4. Выявить отсутствующие измерения: охват, глубина, риски, ограничения, метрики.
   5. Сформулировать вопросы по шаблонам:
      - Уточнение области (включать интеграции или нет?).
      - Приоритет рисков (какие области должны быть обязательными?).
      - Глубина (простой чек-лист или строгий релизный гейт?).
      - Аудитория (кто будет использовать: автор или ревьюер?).
      - Исключения (нужно ли исключить performance?).
      - Пробелы по сценариям (учесть ли recovery/rollback?).

   Правила:
   - Для вариантов используйте компактную таблицу: Option | Candidate | Why It Matters.
   - Не просите повторно то, что уже сказано.
   - Не придумывайте категории — лучше уточнить напрямую.

   Значения по умолчанию (если нет ответа):
   - Глубина: Standard.
   - Аудитория: Reviewer (если про код), иначе Author.
   - Фокус: две наиболее релевантные области.

   После ответов: если остаются ≥2 непокрытых классов сценарием (Alternate / Exception / Recovery / NFR), можно задать до ДВУХ дополнительных вопросов (всего ≤5). Каждый вопрос сопровождайте кратким обоснованием. Остановитесь, если пользователь не хочет продолжать.

3. **Понять запрос пользователя**: совмещайте `$ARGUMENTS` и ответы:
   - Определите тип чек-листа (security, review, deploy, ux ...).
   - Список обязательных пунктов, упомянутых пользователем.
   - Свяжите выбранные фокусы с категориями.
   - При необходимости извлеките контекст из spec/plan/tasks (не выдумывая).

4. **Загрузите контекст фичи**: из FEATURE_DIR прочитайте spec.md, план, tasks (если есть). Подгружайте только релевантные разделы.

5. **Сгенерируйте пункты**: превратите фокусные области в категории. Для каждой — три типа проверок:
   - **Полнота**: охвачены ли все требуемые аспекты.
   - **Ясность**: измеримость, однозначность.
   - **Согласованность**: нет ли противоречий с другими разделами.
   - **Проверяемость**: можно ли объективно проверить требование.
   - **Граничные сценарии**: исключения, отказоустойчивость.
   - **Трассируемость**: сопоставление с документами/решениями.

   **Запрещённые формулировки** — проверка реализации, а не требований:
   - ❌ «Проверить, что кнопка работает»
   - ❌ «Убедиться, что логирование включено»
   - ❌ «Запустить тесты»

   **Разрешённые формулировки** — проверка качества требований:
   - ✅ «Указаны ли метрики производительности для сценария X?»
   - ✅ «Конкретизировано ли определение “быстро” для API Y?»
   - ✅ «Согласованы ли требования безопасности между разделами A и B?»
   - ✅ «Описаны ли негативные сценарии для Z?»

6. **Структура**: используйте шаблон `templates/checklist-template.md`. Если шаблон недоступен — H1, блок с метаданными, затем `##`-разделы с пунктами вида `- [ ] CHK### ...`.

7. **Отчёт**: выведите путь к созданному файлу, количество пунктов, напомните, что каждая генерация создаёт новый чек-лист. Укажите:
   - Выбранные фокусные области.
   - Глубину (depth).
   - Аудиторию.
   - Вербализованные «must have» пункты от пользователя.

> Каждый запуск `/specify-ru.checklist` создаёт новый файл (краткое название). Это удобно для нескольких типов (например, `ux.md`, `security.md`). Следите за чистотой каталога.

## Примеры типов чек-листов

**UX Requirements Quality** — `ux.md`:
- «Определены ли критерии визуальной иерархии с измеримыми показателями?»
- «Указаны ли состояние взаимодействия (hover/focus/active) для всех элементов?»
- «Описаны ли требования доступности (a11y) для интерактивных элементов?»
- «Указаны ли fallback-сценарии при сбое загрузки изображений?»
- «Можно ли измерить “prominent display”?»

**API Requirements Quality** — `api.md`:
- «Определены ли форматы ошибок для всех сценариев?»
- «Заданы ли лимиты rate limiting?»
- «Консистентны ли требования аутентификации между эндпоинтами?»
- «Описаны ли требования retry/timeout для внешних зависимостей?»
- «Документирована ли стратегия версионирования?»

**Performance Requirements Quality** — `performance.md`:
- «Определены ли метрики производительности?»
- «Заданы ли цели для критических пользовательских сценариев?»
- «Описаны ли требования при разных нагрузках?»
- «Можно ли измерить каждый критерий?»
- «Прописаны ли сценарии деградации?»

**Security Requirements Quality** — `security.md`:
- «Указаны ли требования аутентификации для защищаемых ресурсов?»
- «Описана ли защита данных для чувствительной информации?»
- «Есть ли связь требований с моделью угроз/комплаенсом?»
- «Определены ли сценарии реагирования на инциденты?»

## Анти-примеры

**❌ Неверно (тестирует реализацию):**
```markdown
- [ ] CHK001 Проверить, что страницы показывают 3 карточки
- [ ] CHK002 Убедиться, что hover-состояния работают
- [ ] CHK003 Подтвердить, что клик по логотипу ведёт домой
- [ ] CHK004 Проверить, что блок рекомендаций содержит 3-5 элементов
```

**✅ Верно (тестирует качество требований):**
```markdown
- [ ] CHK001 Указаны ли число и размещение «featured episodes»? [Completeness]
- [ ] CHK002 Согласованы ли требования к hover-состояниям? [Consistency]
- [ ] CHK003 Чётко ли определена навигация по бренду? [Clarity]
- [ ] CHK004 Описаны ли критерии отбора связанных эпизодов? [Gap]
- [ ] CHK005 Прописаны ли состояния загрузки данных? [Gap]
- [ ] CHK006 Можно ли измерить «визуальную иерархию»? [Measurability]
```

**Разница**:
- Неверно: проверка поведения.
- Верно: проверка качества требований.
