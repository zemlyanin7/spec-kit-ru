---
description: Создать или обновить спецификацию фичи на основе текстового описания.
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## Ввод пользователя

```text
$ARGUMENTS
```

Вы **ОБЯЗАНЫ** учитывать ввод пользователя перед выполнением дальнейших действий (если он не пустой).

## Общий план

Текст, который пользователь ввёл после `/specify-ru.specify`, **и есть** описание фичи. Считайте, что оно всегда доступно в текущем диалоге, даже если `{ARGS}` ниже показан буквально. Не просите пользователя повторять описание, если команда не была пустой.

Выполните следующее:

1. Запустите скрипт `{SCRIPT}` из корня репозитория и распарсите его JSON-вывод, чтобы получить BRANCH_NAME и SPEC_FILE. Все пути к файлам должны быть абсолютными.  
   **ВАЖНО**: скрипт нужно запускать строго один раз. JSON уже выводится в терминал — используйте его, чтобы получить нужные значения. Если в аргументах есть апостроф (например, "I'm Groot"), экранируйте: `'I'\''m Groot'` или используйте двойные кавычки `"I'm Groot"`.
2. Прочитайте `templates/spec-template.md`, чтобы понять структуру документа.

3. Следуйте этому алгоритму:

    1. Спарсить описание пользователя.  
       Если оно пустое: завершить с ошибкой `ERROR "No feature description provided"`.
    2. Выделить ключевые понятия из описания.  
       Определить: пользователей/актеров, действия, данные, ограничения.
    3. Для неясных моментов:
       - Делайте обоснованные допущения, опираясь на контекст и отраслевые стандарты.
       - Используйте пометки `[NEEDS CLARIFICATION: вопрос]` только если:
         - Выбор существенно влияет на объём фичи или пользовательский опыт;
         - Есть несколько равноправных трактовок с разными последствиями;
         - Не существует разумного значения по умолчанию.
       - **ОГРАНИЧЕНИЕ**: не более трёх пометок `[NEEDS CLARIFICATION]` суммарно.
       - Приоритизируйте вопросы так: область фичи > безопасность/комплаенс > пользовательский опыт > технические детали.
    4. Заполните раздел «Пользовательские сценарии и тестирование».  
       Если нельзя определить сценарии: `ERROR "Cannot determine user scenarios"`.
    5. Сформируйте функциональные требования.  
       Каждое требование должно быть проверяемым. Используйте разумные значения по умолчанию и фиксируйте допущения в разделе Assumptions.
    6. Определите критерии успеха.  
       Они должны быть измеримыми и технологически нейтральными. Включайте количественные метрики (время, производительность, объём) и качественные показатели (успешность выполнения задачи). Каждый критерий должен быть верифицируем без знания реализации.
    7. Определите ключевые сущности (если фича связана с данными).
    8. Завершите: SUCCESS (спецификация готова для планирования).

4. Запишите спецификацию в SPEC_FILE, следуя структуре шаблона и заменяя плейсхолдеры фактической информацией из описания, сохраняя порядок разделов и заголовков.

5. **Проверка качества спецификации**: после первичного заполнения проверьте документ по чек-листу.

   a. **Создайте чек-лист качества**: сгенерируйте файл `FEATURE_DIR/checklists/requirements.md`, используя структуру шаблона, со следующими пунктами:

      ```markdown
      # Specification Quality Checklist: [FEATURE NAME]
      
      **Purpose**: Validate specification completeness and quality before proceeding to planning
      **Created**: [DATE]
      **Feature**: [Link to spec.md]
      
      ## Content Quality
      
      - [ ] No implementation details (languages, frameworks, APIs)
      - [ ] Focused on user value and business needs
      - [ ] Written for non-technical stakeholders
      - [ ] All mandatory sections completed
      
      ## Requirement Completeness
      
      - [ ] No [NEEDS CLARIFICATION] markers remain
      - [ ] Requirements are testable and unambiguous
      - [ ] Success criteria are measurable
      - [ ] Success criteria are technology-agnostic (no implementation details)
      - [ ] All acceptance scenarios are defined
      - [ ] Edge cases are identified
      - [ ] Scope is clearly bounded
      - [ ] Dependencies and assumptions identified
      
      ## Feature Readiness
      
      - [ ] All functional requirements have clear acceptance criteria
      - [ ] User scenarios cover primary flows
      - [ ] Feature meets measurable outcomes defined in Success Criteria
      - [ ] No implementation details leak into specification
      
      ## Notes
      
      - Items marked incomplete require spec updates before `/specify-ru.clarify` or `/specify-ru.plan`
      ```

   b. **Проведите проверку**: пройдитесь по каждому пункту чек-листа, определите, выполнен он или нет, зафиксируйте найденные проблемы (цитируя соответствующие части спецификации).

   c. **Обработка результатов**:
      - **Если все пункты выполнены**: отметьте чек-лист как выполненный и переходите к шагу 6.
      - **Если есть невыполненные пункты (кроме `[NEEDS CLARIFICATION]`)**:
        1. Перечислите, какие пункты провалены, и опишите проблему.
        2. Обновите спецификацию, чтобы исправить замечания.
        3. Повторно запустите проверку (максимум 3 итерации).
        4. Если после трёх итераций остаются проваленные пункты — завершите с ошибкой и укажите причины.
      - **Если есть `[NEEDS CLARIFICATION]`**:
        1. Сформируйте таблицу с вопросами (максимум 3 строки) и предложите варианты ответов (см. оригинальные инструкции).
        2. Дождитесь ответа пользователя и обновите спецификацию.
        3. Повторите проверку.

   d. **Обновляйте чек-лист** после каждой итерации, фиксируя текущий статус.

6. Сообщите о завершении: выведите ветку, путь к файлу спецификации, итог проверки чек-листа и готовность к следующему шагу (`/specify-ru.clarify` или `/specify-ru.plan`).

**ПРИМЕЧАНИЕ**: Скрипт создаёт и переключается на новую ветку, а также инициализирует файл спецификации до записи содержимого.

## Общие рекомендации

### Кратко

- Фокус на **ЧТО** нужно пользователю и **ПОЧЕМУ**.
- Не описывайте **КАК** реализовать (без техстека, API, архитектуры).
- Пишите так, чтобы документ был понятен бизнес-стейкхолдерам.
- Не добавляйте чек-листы внутрь спецификации — для них есть отдельная команда.

### Обязательные и опциональные разделы

- **Обязательные** разделы заполняются для каждой фичи.
- **Опциональные** включаются только если релевантны.
- Если раздел не нужен — удалите его, не оставляйте «N/A».

### Для генерации ИИ

1. **Делайте разумные предположения** на основе контекста и типовых практик.
2. **Фиксируйте допущения** в соответствующем разделе.
3. **Ограничивайте относительные вопросы** — максимум 3 пометки `[NEEDS CLARIFICATION]`.
4. **Приоритет вопросов**: объём фичи > безопасность/конфиденциальность > пользовательский опыт > техдетали.
5. **Мысленно тестируйте документ** — размытые требования должны приводить к провалу пунктов чек-листа.
6. **Типичные области для уточнений** (только если нет разумного дефолта):
   - Границы фичи (что входит/не входит)
   - Типы пользователей и права доступа
   - Требования безопасности/комплаенса

**Примеры допустимых допущений** (не спрашивайте пользователя):

- Срок хранения данных: стандартный для домена.
- Цели по производительности: типичные для веб/мобильных приложений.
- Обработка ошибок: дружелюбные сообщения + корректные фолбэки.
- Метод аутентификации: стандартный (сессии или OAuth2) для веб-приложений.
- Паттерны интеграции: RESTful, если не указано иное.

### Критерии успеха — рекомендации

Критерии должны быть:

1. **Измеримыми** — конкретные метрики (время, %, количество, частота).
2. **Технологически нейтральными** — без упоминаний фреймворков, БД, инструментов.
3. **Ориентированными на пользователя/бизнес** — описывают результат, а не реализацию.
4. **Проверяемыми** — можно протестировать без знания реализации.

**Хорошие примеры**:

- «Пользователь завершает оформление заказа менее чем за 3 минуты».
- «Система поддерживает 10 000 одновременных пользователей».
- «95% поисков завершается менее чем за 1 секунду».
- «Количество обращений в поддержку по теме [X] снижается на 40%».

**Плохие примеры** (слишком технические):

- «Время ответа API <200 мс» — лучше переформулировать в пользовательском контексте.
- «База данных выдерживает 1000 TPS» — ориентируйтесь на пользовательский эффект.
- «Компоненты React рендерятся эффективно» — упоминание конкретного фреймворка.
- «Hit rate Redis выше 80%» — зависит от конкретного инструмента.
